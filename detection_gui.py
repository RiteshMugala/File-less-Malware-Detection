"""
import tkinter as tk
from tkinter import messagebox
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
import pickle

# Load the trained model
with open('trained_model.pkl', 'rb') as file:
    model = pickle.load(file)

# Create the Tkinter GUI application
root = tk.Tk()
root.title("Anomaly Detection GUI")

# Function to preprocess the input data
def preprocess_input(data):
    categorical_cols = ['protocol_type', 'service', 'flag']
    label_encoder = LabelEncoder()
    
    for col in categorical_cols:
        data[col] = label_encoder.fit_transform(data[col])
    
    return data

# Function to predict the output
def predict_output(data):
    prediction = model.predict(data)
    print("Raw Prediction:",prediction)
    if prediction[0] == "anomaly":
        
        return "Malware"
    else:
        
        return "Normal"

# Event handler for the "Predict" button
def predict_button_click():
    input_data = {
        'protocol_type': protocol_type_entry.get(),
        'service': service_entry.get(),
        'flag': flag_entry.get(),
        'src_bytes': float(src_bytes_entry.get()),
        'dst_bytes': float(dst_bytes_entry.get()),
        'count': float(count_entry.get()),
        'same_srv_rate': float(same_srv_rate_entry.get()),
        'diff_srv_rate': float(diff_srv_rate_entry.get()),
        'dst_host_srv_count': float(dst_host_srv_count_entry.get()),
        'dst_host_same_srv_rate': float(dst_host_same_srv_rate_entry.get())
    }

    print("Input Data:", input_data)


    preprocessed_data = preprocess_input(pd.DataFrame(input_data, index=[0]))
    
   # print(f"Preprocessed Data:\n", preprocessed_data)
    print("Preprocessed Data:")
    for row in preprocessed_data.to_dict(orient='records'):
        print(row)
    
    output = predict_output(preprocessed_data)
    messagebox.showinfo("Prediction Result", f"The output is: {output}")

# Create and configure the GUI elements
protocol_type_label = tk.Label(root, text="Protocol Type:")
protocol_type_label.pack()
protocol_type_entry = tk.Entry(root)
protocol_type_entry.pack()

service_label = tk.Label(root, text="Service:")
service_label.pack()
service_entry = tk.Entry(root)
service_entry.pack()

flag_label = tk.Label(root, text="Flag:")
flag_label.pack()
flag_entry = tk.Entry(root)
flag_entry.pack()

src_bytes_label = tk.Label(root, text="Source Bytes:")
src_bytes_label.pack()
src_bytes_entry = tk.Entry(root)
src_bytes_entry.pack()

dst_bytes_label = tk.Label(root, text="Destination Bytes:")
dst_bytes_label.pack()
dst_bytes_entry = tk.Entry(root)
dst_bytes_entry.pack()

count_label = tk.Label(root, text="Count:")
count_label.pack()
count_entry = tk.Entry(root)
count_entry.pack()

same_srv_rate_label = tk.Label(root, text="Same Service Rate:")
same_srv_rate_label.pack()
same_srv_rate_entry = tk.Entry(root)
same_srv_rate_entry.pack()

diff_srv_rate_label = tk.Label(root, text="Different Service Rate:")
diff_srv_rate_label.pack()
diff_srv_rate_entry = tk.Entry(root)
diff_srv_rate_entry.pack()

dst_host_srv_count_label = tk.Label(root, text="Destination Host Service Count:")
dst_host_srv_count_label.pack()
dst_host_srv_count_entry = tk.Entry(root)
dst_host_srv_count_entry.pack()

dst_host_same_srv_rate_label = tk.Label(root, text="Destination Host Same Service Rate:")
dst_host_same_srv_rate_label.pack()
dst_host_same_srv_rate_entry = tk.Entry(root)
dst_host_same_srv_rate_entry.pack()

predict_button = tk.Button(root, text="Predict", command=predict_button_click)
predict_button.pack(pady=10)

# Run the Tkinter event loop
root.mainloop()

"""
import tkinter as tk
from tkinter import messagebox
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
import pickle

# Load the trained model
with open('trained_model.pkl', 'rb') as file:
    model = pickle.load(file)

# Create the Tkinter GUI application
root = tk.Tk()
root.title("Anomaly Detection GUI")


# Function to predict the output
def predict_output(input_data):
    prediction = model.predict(input_data)
    print("Raw Prediction:",prediction)
    if prediction[0] == [1,0]:
        return "Malware"
    else:
        return "Normal"

# Event handler for the "Predict" button
def predict_button_click():
    input_data = {
        'src_bytes': float(src_bytes_entry.get()),
        'dst_bytes': float(dst_bytes_entry.get()),
        'count': float(count_entry.get()),
        'same_srv_rate': float(same_srv_rate_entry.get()),
        'diff_srv_rate': float(diff_srv_rate_entry.get()),
        'dst_host_srv_count': float(dst_host_srv_count_entry.get()),
        'dst_host_same_srv_rate': float(dst_host_same_srv_rate_entry.get())
    }

    print("Input Data:", input_data)

    # Include checkbox values in input data
    input_data['protocol_type'] = protocol_type_var.get()
    input_data['service'] = service_var.get()
    input_data['flag'] = flag_var.get()

    #preprocessed_data = preprocess_input(pd.DataFrame(input_data, index=[0]))

    output = predict_output(pd.DataFrame(input_data, index=[0]))
    messagebox.showinfo("Prediction Result", f"The output is: {output}")

# Create and configure the GUI elements
protocol_type_label = tk.Label(root, text="Protocol Type:")
protocol_type_label.pack()

protocol_type_var = tk.StringVar()
protocol_type_checkboxes_frame = tk.Frame(root)
protocol_type_checkboxes_frame.pack()

protocol_types = ["ICMP", "TCP", "UDP"]
for protocol_type in protocol_types:
    checkbox = tk.Checkbutton(protocol_type_checkboxes_frame, text=protocol_type, variable=protocol_type_var, onvalue=protocol_type)
    checkbox.pack(side="left")

service_label = tk.Label(root, text="Service:")
service_label.pack()

service_var = tk.StringVar()
service_checkboxes_frame = tk.Frame(root)
service_checkboxes_frame.pack()

services = ['domain_u', 'eco_i', 'ecr_i', 'ftp_data', 'http', 'other', 'private', 'smtp', 'uncommon_service']
for service in services:
    checkbox = tk.Checkbutton(service_checkboxes_frame, text=service, variable=service_var, onvalue=service)
    checkbox.pack(side="left")

flag_label = tk.Label(root, text="Flag:")
flag_label.pack()

flag_var = tk.StringVar()
flag_checkboxes_frame = tk.Frame(root)
flag_checkboxes_frame.pack()

flags = ['OTH', 'REJ', 'RSTO', 'RSTOS0', 'RSTR', 'S0', 'S1', 'S2', 'S3', 'SF', 'SH']
for flag in flags:
    checkbox = tk.Checkbutton(flag_checkboxes_frame, text=flag, variable=flag_var, onvalue=flag)
    checkbox.pack(side="left")

src_bytes_label = tk.Label(root, text="Source Bytes:")
src_bytes_label.pack()
src_bytes_entry = tk.Entry(root)
src_bytes_entry.pack()

dst_bytes_label = tk.Label(root, text="Destination Bytes:")
dst_bytes_label.pack()
dst_bytes_entry = tk.Entry(root)
dst_bytes_entry.pack()

count_label = tk.Label(root, text="Count:")
count_label.pack()
count_entry = tk.Entry(root)
count_entry.pack()

same_srv_rate_label = tk.Label(root, text="Same Service Rate:")
same_srv_rate_label.pack()
same_srv_rate_entry = tk.Entry(root)
same_srv_rate_entry.pack()

diff_srv_rate_label = tk.Label(root, text="Different Service Rate:")
diff_srv_rate_label.pack()
diff_srv_rate_entry = tk.Entry(root)
diff_srv_rate_entry.pack()

dst_host_srv_count_label = tk.Label(root, text="Destination Host Service Count:")
dst_host_srv_count_label.pack()
dst_host_srv_count_entry = tk.Entry(root)
dst_host_srv_count_entry.pack()

dst_host_same_srv_rate_label = tk.Label(root, text="Destination Host Same Service Rate:")
dst_host_same_srv_rate_label.pack()
dst_host_same_srv_rate_entry = tk.Entry(root)
dst_host_same_srv_rate_entry.pack()

predict_button = tk.Button(root, text="Predict", command=predict_button_click)
predict_button.pack(pady=10)

# Run the Tkinter event loop
root.mainloop()
